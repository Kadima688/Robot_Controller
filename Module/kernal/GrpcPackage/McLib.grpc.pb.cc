// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: McLib.proto

#include "McLib.pb.h"
#include "McLib.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace SoftKernelHmiTest {

static const char* McLibServer_method_names[] = {
  "/SoftKernelHmiTest.McLibServer/MC_Power",
  "/SoftKernelHmiTest.McLibServer/MC_Stop",
  "/SoftKernelHmiTest.McLibServer/MC_MoveAbsolute",
  "/SoftKernelHmiTest.McLibServer/MC_MoveRelative",
  "/SoftKernelHmiTest.McLibServer/MC_SetPostion",
  "/SoftKernelHmiTest.McLibServer/MC_MoveContinuousAbsolute",
  "/SoftKernelHmiTest.McLibServer/MC_MoveContinuousRelative",
  "/SoftKernelHmiTest.McLibServer/MC_ReadActualPosition",
  "/SoftKernelHmiTest.McLibServer/MC_MoveLinearRelative",
  "/SoftKernelHmiTest.McLibServer/MC_MoveLinearAbsolute",
  "/SoftKernelHmiTest.McLibServer/Mc_AddAxisToGroup",
  "/SoftKernelHmiTest.McLibServer/MC_RemoveAxisFromGroup",
  "/SoftKernelHmiTest.McLibServer/MC_GroupEnable",
  "/SoftKernelHmiTest.McLibServer/MC_GroupDisable",
  "/SoftKernelHmiTest.McLibServer/MC_UngroupAllAxes",
  "/SoftKernelHmiTest.McLibServer/MC_GroupInterrupt",
  "/SoftKernelHmiTest.McLibServer/MC_GroupContinue",
  "/SoftKernelHmiTest.McLibServer/MC_GroupStop",
  "/SoftKernelHmiTest.McLibServer/MC_GroupSetPosition",
};

std::unique_ptr< McLibServer::Stub> McLibServer::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< McLibServer::Stub> stub(new McLibServer::Stub(channel));
  return stub;
}

McLibServer::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_MC_Power_(McLibServer_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_Stop_(McLibServer_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveAbsolute_(McLibServer_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveRelative_(McLibServer_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_SetPostion_(McLibServer_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveContinuousAbsolute_(McLibServer_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveContinuousRelative_(McLibServer_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_ReadActualPosition_(McLibServer_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveLinearRelative_(McLibServer_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_MoveLinearAbsolute_(McLibServer_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Mc_AddAxisToGroup_(McLibServer_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_RemoveAxisFromGroup_(McLibServer_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupEnable_(McLibServer_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupDisable_(McLibServer_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_UngroupAllAxes_(McLibServer_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupInterrupt_(McLibServer_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupContinue_(McLibServer_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupStop_(McLibServer_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MC_GroupSetPosition_(McLibServer_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status McLibServer::Stub::MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_Power_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_Power_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_Power_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::Power, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_Power_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_PowerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_Stop_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_Stop_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_Stop_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::Stop, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_Stop_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_StopRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveAbsolute_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveAbsolute_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveAbsolute_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveAbsolute, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveAbsolute_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveAbsoluteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveRelative_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveRelative_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveRelative_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveAbsolute, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveRelative_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveRelativeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_SetPostion_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_SetPostion_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_SetPostion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::SetPostion, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_SetPostion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_SetPostionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveContinuousAbsolute_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveContinuousAbsolute_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveContinuousAbsolute_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveContinuousAbsolute, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveContinuousAbsolute_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveContinuousAbsoluteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveContinuousRelative_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveContinuousRelative_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveContinuousRelative_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveContinuousAbsolute, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveContinuousRelative_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveContinuousRelativeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::SoftKernelHmiTest::AxesPosition* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_ReadActualPosition_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_ReadActualPosition_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_ReadActualPosition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>* McLibServer::Stub::PrepareAsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::AxesPosition, ::SoftKernelHmiTest::ReadActualPosition, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_ReadActualPosition_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>* McLibServer::Stub::AsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_ReadActualPositionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveLinearRelative_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveLinearRelative_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveLinearRelative_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveLinearRelative, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveLinearRelative_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveLinearRelativeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_MoveLinearAbsolute_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveLinearAbsolute_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_MoveLinearAbsolute_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::MoveLinearRelative, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_MoveLinearAbsolute_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_MoveLinearAbsoluteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Mc_AddAxisToGroup_, context, request, response);
}

void McLibServer::Stub::experimental_async::Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Mc_AddAxisToGroup_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Mc_AddAxisToGroup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::AddAxisToGroup, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Mc_AddAxisToGroup_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMc_AddAxisToGroupRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_RemoveAxisFromGroup_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_RemoveAxisFromGroup_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_RemoveAxisFromGroup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::RemoveAxisFromGroup, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_RemoveAxisFromGroup_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_RemoveAxisFromGroupRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupEnable_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupEnable_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupEnable_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupEnable, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupEnable_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupEnableRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupDisable_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupDisable_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupDisable_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupDisable, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupDisable_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupDisableRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_UngroupAllAxes_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_UngroupAllAxes_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_UngroupAllAxes_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::UngroupAllAxes, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_UngroupAllAxes_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_UngroupAllAxesRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupInterrupt_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupInterrupt_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupInterrupt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupInterrupt, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupInterrupt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupInterruptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupContinue_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupContinue_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupContinue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupContinue, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupContinue_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupContinueRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupStop_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupStop_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupStop_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupStop, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupStop_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupStopRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status McLibServer::Stub::MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::SoftKernelHmiTest::McResult* response) {
  return ::grpc::internal::BlockingUnaryCall< ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MC_GroupSetPosition_, context, request, response);
}

void McLibServer::Stub::experimental_async::MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupSetPosition_, context, request, response, std::move(f));
}

void McLibServer::Stub::experimental_async::MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MC_GroupSetPosition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::PrepareAsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::SoftKernelHmiTest::McResult, ::SoftKernelHmiTest::GroupSetPosition, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MC_GroupSetPosition_, context, request);
}

::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* McLibServer::Stub::AsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMC_GroupSetPositionRaw(context, request, cq);
  result->StartCall();
  return result;
}

McLibServer::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::Power* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_Power(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::Stop* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_Stop(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveAbsolute* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveAbsolute(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveAbsolute* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveRelative(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::SetPostion* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_SetPostion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveContinuousAbsolute* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveContinuousAbsolute(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveContinuousAbsolute* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveContinuousRelative(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::ReadActualPosition* req,
             ::SoftKernelHmiTest::AxesPosition* resp) {
               return service->MC_ReadActualPosition(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveLinearRelative* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveLinearRelative(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::MoveLinearRelative* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_MoveLinearAbsolute(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::AddAxisToGroup* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->Mc_AddAxisToGroup(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::RemoveAxisFromGroup* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_RemoveAxisFromGroup(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupEnable* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupEnable(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupDisable* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupDisable(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::UngroupAllAxes* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_UngroupAllAxes(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupInterrupt* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupInterrupt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupContinue* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupContinue(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupStop* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupStop(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      McLibServer_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< McLibServer::Service, ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](McLibServer::Service* service,
             ::grpc::ServerContext* ctx,
             const ::SoftKernelHmiTest::GroupSetPosition* req,
             ::SoftKernelHmiTest::McResult* resp) {
               return service->MC_GroupSetPosition(ctx, req, resp);
             }, this)));
}

McLibServer::Service::~Service() {
}

::grpc::Status McLibServer::Service::MC_Power(::grpc::ServerContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_Stop(::grpc::ServerContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_SetPostion(::grpc::ServerContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveContinuousAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveContinuousRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_ReadActualPosition(::grpc::ServerContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveLinearRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_MoveLinearAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::Mc_AddAxisToGroup(::grpc::ServerContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_RemoveAxisFromGroup(::grpc::ServerContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupEnable(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupDisable(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_UngroupAllAxes(::grpc::ServerContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupInterrupt(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupContinue(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupStop(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status McLibServer::Service::MC_GroupSetPosition(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace SoftKernelHmiTest

