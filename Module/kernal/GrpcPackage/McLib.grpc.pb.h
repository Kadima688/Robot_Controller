// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: McLib.proto
#ifndef GRPC_McLib_2eproto__INCLUDED
#define GRPC_McLib_2eproto__INCLUDED

#include "McLib.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace SoftKernelHmiTest {

// The greeting service definition.
class McLibServer final {
 public:
  static constexpr char const* service_full_name() {
    return "SoftKernelHmiTest.McLibServer";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_PowerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_PowerRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_StopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_StopRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveAbsoluteRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveRelativeRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_SetPostionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_SetPostionRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveContinuousAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveContinuousAbsoluteRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveContinuousRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveContinuousRelativeRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::SoftKernelHmiTest::AxesPosition* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>> AsyncMC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>>(AsyncMC_ReadActualPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>> PrepareAsyncMC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>>(PrepareAsyncMC_ReadActualPositionRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveLinearRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveLinearRelativeRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveLinearAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveLinearAbsoluteRaw(context, request, cq));
    }
    virtual ::grpc::Status Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMc_AddAxisToGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMc_AddAxisToGroupRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_RemoveAxisFromGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_RemoveAxisFromGroupRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupEnableRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupDisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupDisableRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_UngroupAllAxesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_UngroupAllAxesRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupInterruptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupInterruptRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupContinueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupContinueRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupStopRaw(context, request, cq));
    }
    virtual ::grpc::Status MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::SoftKernelHmiTest::McResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupSetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupSetPositionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>* AsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::AxesPosition>* PrepareAsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_PowerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_PowerRaw(context, request, cq));
    }
    ::grpc::Status MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_StopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_StopRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveAbsoluteRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveRelativeRaw(context, request, cq));
    }
    ::grpc::Status MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_SetPostionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_SetPostionRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveContinuousAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveContinuousAbsoluteRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveContinuousRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveContinuousRelativeRaw(context, request, cq));
    }
    ::grpc::Status MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::SoftKernelHmiTest::AxesPosition* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>> AsyncMC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>>(AsyncMC_ReadActualPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>> PrepareAsyncMC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>>(PrepareAsyncMC_ReadActualPositionRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveLinearRelativeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveLinearRelativeRaw(context, request, cq));
    }
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_MoveLinearAbsoluteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_MoveLinearAbsoluteRaw(context, request, cq));
    }
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMc_AddAxisToGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMc_AddAxisToGroupRaw(context, request, cq));
    }
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_RemoveAxisFromGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_RemoveAxisFromGroupRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupEnableRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupDisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupDisableRaw(context, request, cq));
    }
    ::grpc::Status MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_UngroupAllAxesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_UngroupAllAxesRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupInterruptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupInterruptRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupContinueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupContinueRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupStopRaw(context, request, cq));
    }
    ::grpc::Status MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::SoftKernelHmiTest::McResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> AsyncMC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(AsyncMC_GroupSetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>> PrepareAsyncMC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>>(PrepareAsyncMC_GroupSetPositionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_Power(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_Stop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_SetPostion(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveContinuousAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveContinuousRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_ReadActualPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveLinearRelative(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_MoveLinearAbsolute(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Mc_AddAxisToGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_RemoveAxisFromGroup(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupEnable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupDisable(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_UngroupAllAxes(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupInterrupt(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupContinue(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupStop(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MC_GroupSetPosition(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_PowerRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Power& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_StopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::Stop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_SetPostionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::SetPostion& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveContinuousAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveContinuousRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>* AsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::AxesPosition>* PrepareAsyncMC_ReadActualPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::ReadActualPosition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveLinearRelativeRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_MoveLinearAbsoluteRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::MoveLinearRelative& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMc_AddAxisToGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::AddAxisToGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_RemoveAxisFromGroupRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupEnableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupEnable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupDisableRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupDisable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_UngroupAllAxesRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::UngroupAllAxes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupInterruptRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupInterrupt& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupContinueRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupContinue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupStopRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupStop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* AsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SoftKernelHmiTest::McResult>* PrepareAsyncMC_GroupSetPositionRaw(::grpc::ClientContext* context, const ::SoftKernelHmiTest::GroupSetPosition& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_MC_Power_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveAbsolute_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveRelative_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_SetPostion_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveContinuousAbsolute_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveContinuousRelative_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_ReadActualPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveLinearRelative_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_MoveLinearAbsolute_;
    const ::grpc::internal::RpcMethod rpcmethod_Mc_AddAxisToGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_RemoveAxisFromGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupEnable_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupDisable_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_UngroupAllAxes_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupInterrupt_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupContinue_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupStop_;
    const ::grpc::internal::RpcMethod rpcmethod_MC_GroupSetPosition_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status MC_Power(::grpc::ServerContext* context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_Stop(::grpc::ServerContext* context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_MoveRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_SetPostion(::grpc::ServerContext* context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response);
    virtual ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupEnable(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupDisable(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupContinue(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupStop(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response);
    virtual ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_Power() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_Power(::grpc::ServerContext* context, ::SoftKernelHmiTest::Power* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_Stop() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_Stop(::grpc::ServerContext* context, ::SoftKernelHmiTest::Stop* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveAbsolute() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveAbsolute(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveAbsolute* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveRelative() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveRelative(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveAbsolute* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_SetPostion() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_SetPostion(::grpc::ServerContext* context, ::SoftKernelHmiTest::SetPostion* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveContinuousAbsolute() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveContinuousAbsolute(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveContinuousRelative() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveContinuousRelative(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_ReadActualPosition() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_ReadActualPosition(::grpc::ServerContext* context, ::SoftKernelHmiTest::ReadActualPosition* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::AxesPosition>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveLinearRelative() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveLinearRelative(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveLinearRelative* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_MoveLinearAbsolute() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveLinearAbsolute(::grpc::ServerContext* context, ::SoftKernelHmiTest::MoveLinearRelative* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Mc_AddAxisToGroup() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMc_AddAxisToGroup(::grpc::ServerContext* context, ::SoftKernelHmiTest::AddAxisToGroup* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_RemoveAxisFromGroup() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_RemoveAxisFromGroup(::grpc::ServerContext* context, ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupEnable() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupEnable(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupEnable* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupDisable() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupDisable(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupDisable* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_UngroupAllAxes() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_UngroupAllAxes(::grpc::ServerContext* context, ::SoftKernelHmiTest::UngroupAllAxes* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupInterrupt() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupInterrupt(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupInterrupt* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupContinue() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupContinue(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupContinue* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupStop() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupStop(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupStop* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MC_GroupSetPosition() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupSetPosition(::grpc::ServerContext* context, ::SoftKernelHmiTest::GroupSetPosition* request, ::grpc::ServerAsyncResponseWriter< ::SoftKernelHmiTest::McResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_MC_Power<WithAsyncMethod_MC_Stop<WithAsyncMethod_MC_MoveAbsolute<WithAsyncMethod_MC_MoveRelative<WithAsyncMethod_MC_SetPostion<WithAsyncMethod_MC_MoveContinuousAbsolute<WithAsyncMethod_MC_MoveContinuousRelative<WithAsyncMethod_MC_ReadActualPosition<WithAsyncMethod_MC_MoveLinearRelative<WithAsyncMethod_MC_MoveLinearAbsolute<WithAsyncMethod_Mc_AddAxisToGroup<WithAsyncMethod_MC_RemoveAxisFromGroup<WithAsyncMethod_MC_GroupEnable<WithAsyncMethod_MC_GroupDisable<WithAsyncMethod_MC_UngroupAllAxes<WithAsyncMethod_MC_GroupInterrupt<WithAsyncMethod_MC_GroupContinue<WithAsyncMethod_MC_GroupStop<WithAsyncMethod_MC_GroupSetPosition<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_Power() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::Power* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_Power(context, request, response); }));}
    void SetMessageAllocatorFor_MC_Power(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_Power(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_Power(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_Stop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::Stop* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_Stop(context, request, response); }));}
    void SetMessageAllocatorFor_MC_Stop(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_Stop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveAbsolute(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveAbsolute(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveAbsolute* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveRelative(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveRelative(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_SetPostion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::SetPostion* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_SetPostion(context, request, response); }));}
    void SetMessageAllocatorFor_MC_SetPostion(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_SetPostion(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_SetPostion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveContinuousAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveContinuousAbsolute(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveContinuousAbsolute(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveContinuousAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveContinuousAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveContinuousRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveContinuousAbsolute* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveContinuousRelative(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveContinuousRelative(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveContinuousRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveContinuousRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_ReadActualPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::ReadActualPosition* request, ::SoftKernelHmiTest::AxesPosition* response) { return this->MC_ReadActualPosition(context, request, response); }));}
    void SetMessageAllocatorFor_MC_ReadActualPosition(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_ReadActualPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_ReadActualPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveLinearRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveLinearRelative(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveLinearRelative(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveLinearRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveLinearRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_MoveLinearAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::MoveLinearRelative* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_MoveLinearAbsolute(context, request, response); }));}
    void SetMessageAllocatorFor_MC_MoveLinearAbsolute(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveLinearAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveLinearAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Mc_AddAxisToGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::AddAxisToGroup* request, ::SoftKernelHmiTest::McResult* response) { return this->Mc_AddAxisToGroup(context, request, response); }));}
    void SetMessageAllocatorFor_Mc_AddAxisToGroup(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Mc_AddAxisToGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Mc_AddAxisToGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_RemoveAxisFromGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::RemoveAxisFromGroup* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_RemoveAxisFromGroup(context, request, response); }));}
    void SetMessageAllocatorFor_MC_RemoveAxisFromGroup(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_RemoveAxisFromGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_RemoveAxisFromGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupEnable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupEnable* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupEnable(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupEnable(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupEnable(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupEnable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupDisable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupDisable* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupDisable(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupDisable(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupDisable(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupDisable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_UngroupAllAxes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::UngroupAllAxes* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_UngroupAllAxes(context, request, response); }));}
    void SetMessageAllocatorFor_MC_UngroupAllAxes(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_UngroupAllAxes(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_UngroupAllAxes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupInterrupt() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupInterrupt* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupInterrupt(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupInterrupt(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupInterrupt(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupInterrupt(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupContinue() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupContinue* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupContinue(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupContinue(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupContinue(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupContinue(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupStop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupStop* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupStop(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupStop(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupStop(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupStop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MC_GroupSetPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SoftKernelHmiTest::GroupSetPosition* request, ::SoftKernelHmiTest::McResult* response) { return this->MC_GroupSetPosition(context, request, response); }));}
    void SetMessageAllocatorFor_MC_GroupSetPosition(
        ::grpc::experimental::MessageAllocator< ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupSetPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupSetPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_MC_Power<ExperimentalWithCallbackMethod_MC_Stop<ExperimentalWithCallbackMethod_MC_MoveAbsolute<ExperimentalWithCallbackMethod_MC_MoveRelative<ExperimentalWithCallbackMethod_MC_SetPostion<ExperimentalWithCallbackMethod_MC_MoveContinuousAbsolute<ExperimentalWithCallbackMethod_MC_MoveContinuousRelative<ExperimentalWithCallbackMethod_MC_ReadActualPosition<ExperimentalWithCallbackMethod_MC_MoveLinearRelative<ExperimentalWithCallbackMethod_MC_MoveLinearAbsolute<ExperimentalWithCallbackMethod_Mc_AddAxisToGroup<ExperimentalWithCallbackMethod_MC_RemoveAxisFromGroup<ExperimentalWithCallbackMethod_MC_GroupEnable<ExperimentalWithCallbackMethod_MC_GroupDisable<ExperimentalWithCallbackMethod_MC_UngroupAllAxes<ExperimentalWithCallbackMethod_MC_GroupInterrupt<ExperimentalWithCallbackMethod_MC_GroupContinue<ExperimentalWithCallbackMethod_MC_GroupStop<ExperimentalWithCallbackMethod_MC_GroupSetPosition<Service > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_MC_Power<ExperimentalWithCallbackMethod_MC_Stop<ExperimentalWithCallbackMethod_MC_MoveAbsolute<ExperimentalWithCallbackMethod_MC_MoveRelative<ExperimentalWithCallbackMethod_MC_SetPostion<ExperimentalWithCallbackMethod_MC_MoveContinuousAbsolute<ExperimentalWithCallbackMethod_MC_MoveContinuousRelative<ExperimentalWithCallbackMethod_MC_ReadActualPosition<ExperimentalWithCallbackMethod_MC_MoveLinearRelative<ExperimentalWithCallbackMethod_MC_MoveLinearAbsolute<ExperimentalWithCallbackMethod_Mc_AddAxisToGroup<ExperimentalWithCallbackMethod_MC_RemoveAxisFromGroup<ExperimentalWithCallbackMethod_MC_GroupEnable<ExperimentalWithCallbackMethod_MC_GroupDisable<ExperimentalWithCallbackMethod_MC_UngroupAllAxes<ExperimentalWithCallbackMethod_MC_GroupInterrupt<ExperimentalWithCallbackMethod_MC_GroupContinue<ExperimentalWithCallbackMethod_MC_GroupStop<ExperimentalWithCallbackMethod_MC_GroupSetPosition<Service > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_Power() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_Stop() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveAbsolute() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveRelative() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_SetPostion() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveContinuousAbsolute() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveContinuousRelative() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_ReadActualPosition() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveLinearRelative() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_MoveLinearAbsolute() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Mc_AddAxisToGroup() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_RemoveAxisFromGroup() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupEnable() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupDisable() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_UngroupAllAxes() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupInterrupt() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupContinue() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupStop() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MC_GroupSetPosition() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_Power() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_Power(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_Stop() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_Stop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveAbsolute() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveAbsolute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveRelative() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveRelative(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_SetPostion() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_SetPostion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveContinuousAbsolute() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveContinuousAbsolute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveContinuousRelative() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveContinuousRelative(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_ReadActualPosition() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_ReadActualPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveLinearRelative() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveLinearRelative(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_MoveLinearAbsolute() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_MoveLinearAbsolute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Mc_AddAxisToGroup() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMc_AddAxisToGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_RemoveAxisFromGroup() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_RemoveAxisFromGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupEnable() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupEnable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupDisable() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupDisable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_UngroupAllAxes() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_UngroupAllAxes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupInterrupt() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupInterrupt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupContinue() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupContinue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupStop() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MC_GroupSetPosition() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMC_GroupSetPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_Power() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_Power(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_Power(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_Power(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_Stop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_Stop(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_Stop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveAbsolute(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveRelative(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_SetPostion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_SetPostion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_SetPostion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_SetPostion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveContinuousAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveContinuousAbsolute(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveContinuousAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveContinuousAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveContinuousRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveContinuousRelative(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveContinuousRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveContinuousRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_ReadActualPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_ReadActualPosition(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_ReadActualPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_ReadActualPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveLinearRelative() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveLinearRelative(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveLinearRelative(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveLinearRelative(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_MoveLinearAbsolute() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_MoveLinearAbsolute(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_MoveLinearAbsolute(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_MoveLinearAbsolute(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Mc_AddAxisToGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Mc_AddAxisToGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Mc_AddAxisToGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Mc_AddAxisToGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_RemoveAxisFromGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_RemoveAxisFromGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_RemoveAxisFromGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_RemoveAxisFromGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupEnable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupEnable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupEnable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupEnable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupDisable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupDisable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupDisable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupDisable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_UngroupAllAxes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_UngroupAllAxes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_UngroupAllAxes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_UngroupAllAxes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupInterrupt() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupInterrupt(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupInterrupt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupInterrupt(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupContinue() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupContinue(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupContinue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupContinue(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupStop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupStop(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupStop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupStop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MC_GroupSetPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MC_GroupSetPosition(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MC_GroupSetPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MC_GroupSetPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_Power : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_Power() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::Power, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_Power(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_Power() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_Power(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Power* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_Power(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::Power,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_Stop() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::Stop, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_Stop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_Stop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::Stop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_Stop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::Stop,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveAbsolute() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveAbsolute(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveAbsolute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveAbsolute,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveRelative() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveAbsolute, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveRelative(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveRelative(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveAbsolute,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_SetPostion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_SetPostion() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::SetPostion, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_SetPostion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_SetPostion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_SetPostion(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::SetPostion* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_SetPostion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::SetPostion,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveContinuousAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveContinuousAbsolute() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveContinuousAbsolute(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveContinuousAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveContinuousAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveContinuousAbsolute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveContinuousAbsolute,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveContinuousRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveContinuousRelative() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveContinuousAbsolute, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveContinuousRelative(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveContinuousRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveContinuousRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveContinuousAbsolute* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveContinuousRelative(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveContinuousAbsolute,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_ReadActualPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_ReadActualPosition() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::ReadActualPosition, ::SoftKernelHmiTest::AxesPosition>* streamer) {
                       return this->StreamedMC_ReadActualPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_ReadActualPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_ReadActualPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::ReadActualPosition* /*request*/, ::SoftKernelHmiTest::AxesPosition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_ReadActualPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::ReadActualPosition,::SoftKernelHmiTest::AxesPosition>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveLinearRelative : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveLinearRelative() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveLinearRelative(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveLinearRelative() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveLinearRelative(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveLinearRelative(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveLinearRelative,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_MoveLinearAbsolute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_MoveLinearAbsolute() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::MoveLinearRelative, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_MoveLinearAbsolute(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_MoveLinearAbsolute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_MoveLinearAbsolute(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::MoveLinearRelative* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_MoveLinearAbsolute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::MoveLinearRelative,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Mc_AddAxisToGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Mc_AddAxisToGroup() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::AddAxisToGroup, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMc_AddAxisToGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Mc_AddAxisToGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Mc_AddAxisToGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::AddAxisToGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMc_AddAxisToGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::AddAxisToGroup,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_RemoveAxisFromGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_RemoveAxisFromGroup() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::RemoveAxisFromGroup, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_RemoveAxisFromGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_RemoveAxisFromGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_RemoveAxisFromGroup(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::RemoveAxisFromGroup* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_RemoveAxisFromGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::RemoveAxisFromGroup,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupEnable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupEnable() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupEnable, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupEnable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupEnable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupEnable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupEnable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupEnable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupEnable,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupDisable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupDisable() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupDisable, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupDisable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupDisable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupDisable(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupDisable* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupDisable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupDisable,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_UngroupAllAxes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_UngroupAllAxes() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::UngroupAllAxes, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_UngroupAllAxes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_UngroupAllAxes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_UngroupAllAxes(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::UngroupAllAxes* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_UngroupAllAxes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::UngroupAllAxes,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupInterrupt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupInterrupt() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupInterrupt, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupInterrupt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupInterrupt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupInterrupt(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupInterrupt* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupInterrupt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupInterrupt,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupContinue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupContinue() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupContinue, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupContinue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupContinue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupContinue(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupContinue* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupContinue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupContinue,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupStop() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupStop, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupStop(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupStop* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupStop,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MC_GroupSetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MC_GroupSetPosition() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SoftKernelHmiTest::GroupSetPosition, ::SoftKernelHmiTest::McResult>* streamer) {
                       return this->StreamedMC_GroupSetPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MC_GroupSetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MC_GroupSetPosition(::grpc::ServerContext* /*context*/, const ::SoftKernelHmiTest::GroupSetPosition* /*request*/, ::SoftKernelHmiTest::McResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMC_GroupSetPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SoftKernelHmiTest::GroupSetPosition,::SoftKernelHmiTest::McResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_MC_Power<WithStreamedUnaryMethod_MC_Stop<WithStreamedUnaryMethod_MC_MoveAbsolute<WithStreamedUnaryMethod_MC_MoveRelative<WithStreamedUnaryMethod_MC_SetPostion<WithStreamedUnaryMethod_MC_MoveContinuousAbsolute<WithStreamedUnaryMethod_MC_MoveContinuousRelative<WithStreamedUnaryMethod_MC_ReadActualPosition<WithStreamedUnaryMethod_MC_MoveLinearRelative<WithStreamedUnaryMethod_MC_MoveLinearAbsolute<WithStreamedUnaryMethod_Mc_AddAxisToGroup<WithStreamedUnaryMethod_MC_RemoveAxisFromGroup<WithStreamedUnaryMethod_MC_GroupEnable<WithStreamedUnaryMethod_MC_GroupDisable<WithStreamedUnaryMethod_MC_UngroupAllAxes<WithStreamedUnaryMethod_MC_GroupInterrupt<WithStreamedUnaryMethod_MC_GroupContinue<WithStreamedUnaryMethod_MC_GroupStop<WithStreamedUnaryMethod_MC_GroupSetPosition<Service > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_MC_Power<WithStreamedUnaryMethod_MC_Stop<WithStreamedUnaryMethod_MC_MoveAbsolute<WithStreamedUnaryMethod_MC_MoveRelative<WithStreamedUnaryMethod_MC_SetPostion<WithStreamedUnaryMethod_MC_MoveContinuousAbsolute<WithStreamedUnaryMethod_MC_MoveContinuousRelative<WithStreamedUnaryMethod_MC_ReadActualPosition<WithStreamedUnaryMethod_MC_MoveLinearRelative<WithStreamedUnaryMethod_MC_MoveLinearAbsolute<WithStreamedUnaryMethod_Mc_AddAxisToGroup<WithStreamedUnaryMethod_MC_RemoveAxisFromGroup<WithStreamedUnaryMethod_MC_GroupEnable<WithStreamedUnaryMethod_MC_GroupDisable<WithStreamedUnaryMethod_MC_UngroupAllAxes<WithStreamedUnaryMethod_MC_GroupInterrupt<WithStreamedUnaryMethod_MC_GroupContinue<WithStreamedUnaryMethod_MC_GroupStop<WithStreamedUnaryMethod_MC_GroupSetPosition<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace SoftKernelHmiTest


#endif  // GRPC_McLib_2eproto__INCLUDED
